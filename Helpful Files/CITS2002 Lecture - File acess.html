<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="https://www.w3.org/1999/xhtml" id="uwo"><head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <link media="all" href="CITS2002%20Lecture%20-%20File%20acess_files/cits2002-lectures.css" type="text/css" rel="stylesheet">
    <title>CITS2002 Systems Programming, Lecture 8, </title>
</head>

<body style="font-family: Arial, Helvetica, sans-serif;">

<table id="box" style="width: 100%;">
<tbody><tr style="height: 64px;">
    <td style="color: white; text-align: left; vertical-align: middle;">
        <img style="height: 48px;" src="CITS2002%20Lecture%20-%20File%20acess_files/uwacrest.png">
    </td>
    <td style="color: white; font-size: 1.2em; text-align: right; vertical-align: middle; white-space: nowrap;">
        CITS2002 Systems Programming&nbsp;&nbsp;
    </td>
</tr>
</tbody></table>

<table style="width: 100%; background: url(../images/search-background.gif) repeat-x bottom;">
<tbody><tr>
    <td style="vertical-align: middle; white-space: nowrap; padding-left: 0px; "></td>
    <td style="vertical-align: middle; white-space: nowrap;"></td>
    <td style="vertical-align: middle; white-space: nowrap;"></td>
    <td style="vertical-align: middle; white-space: nowrap;">

    </td><td id="topmenu"> <img src="CITS2002%20Lecture%20-%20File%20acess_files/bullet-link.gif">
	<a id="topmenu" href="https://teaching.csse.uwa.edu.au/units/CITS2002/index.php">CITS2002</a></td>
    <td id="topmenu"> <img src="CITS2002%20Lecture%20-%20File%20acess_files/bullet-link.gif">
	<a id="topmenu" href="https://teaching.csse.uwa.edu.au/units/CITS2002/schedule.php">CITS2002 schedule</a></td>

    <td style="width: 100%;">&nbsp;</td>
</tr><tr>
</tr></tbody></table>

<table><tbody><tr>
<td style="font-size: 1.0em; text-align: left; width: 100%;">

<!-- ----------------- BOTTOM-OF-HEADER ----------------------------- -->

<h3>Raw input and output</h3>

We've recently seen how C11 employs arrays of characters to represent strings,
treating the NULL-byte with special significance.
<p>

At the lowest level,
an operating system will only communicate using <i>bytes</i>,
not with higher-level integers or floating-point values.
C11 employs arrays of characters to hold the bytes
in requests for
<i>raw input and output</i>.
</p><p>

</p><h3>File descriptors - reading from a file</h3>

Unix-based operating systems provide <i>file descriptors</i>,
simple integer values,
to identify 'communication channels' -
such as files,
interprocess-communication pipes,
(some) devices,
and network connections (sockets).
<p>

In combination, our C11 programs will use integer file descriptors 
and arrays of characters to request that the operating system performs input
and output on behalf of the process -
see <i>man&nbsp;2&nbsp;open</i>.

</p><table><tbody><tr>
<td class="code" style="padding: 4px; vertical-align: top;">
<pre><tt><font color="blue">#include  &lt;stdio.h&gt;</font>
<font color="blue">#include  &lt;fcntl.h&gt;</font>
<font color="blue">#include  &lt;stdlib.h&gt;</font>
<font color="blue">#include  &lt;unistd.h&gt;</font>

<font color="blue">#define  MYSIZE      10000</font>

<b>void</b> read_using_descriptor(<b>char</b> filename[])        
{
<font color="green"><i>//  ATTEMPT TO OPEN THE FILE FOR READ-ONLY ACCESS</i></font>
    <font color="red"><b>int fd    = open(filename, O_RDONLY)</b></font>;

<font color="green"><i>//  CHECK TO SEE IF FILE COULD BE OPENED</i></font>
    <b>if</b>(<font color="red"><b>fd == -1</b></font>) {
        printf("cannot open '%s'\n", filename);
        exit(EXIT_FAILURE);
    }

<font color="green"><i>//  DEFINE A CHARACTER ARRAY TO HOLD THE FILE'S CONTENTS</i></font>
    <b>char</b>   buffer[MYSIZE];
    size_t got;

<font color="green"><i>//  PERFORM MULTIPLE READs OF FILE UNTIL END-OF-FILE REACHED  </i></font>
    <b>while</b>(<font color="red"><b>(got = read(fd, buffer, sizeof buffer)) &gt; 0</b></font>) {  
        .....
    }

<font color="green"><i>//  INDICATE THAT THE PROCESS WILL NO LONGER ACCESS FILE</i></font>
    <font color="red"><b>close(fd)</b></font>;
}
</tt></pre>
</td>
</tr></tbody></table>
<p>

Note that the functions
<i>open</i>,
<i>read</i>, and
<i>close</i>
are not C11 functions
but operating system <b>system-calls</b>,
providing the interface between our user-level program
and the operating system's implementation.
	</p><p>
	</p><div style="font-size: 0.7em; color: #888888">
	    CITS2002 Systems Programming, Lecture 8, p1, 16th August 2022.
	</div>
	<hr style="text-align: center; width: 85%;">
	<br>
<h3>File descriptors - writing to a file</h3>

Similarly,
we use integer file descriptors and arrays of characters
to write data to a file.

We require a different file descriptor for each file -
the descriptor identifies the file to use and the operating system
(internally) remembers the requested (permitted)
form of access.

<h3>Copying a file using file descriptors</h3>

<table><tbody><tr>
<td class="code" style="padding: 4px; vertical-align: top;">
<pre><tt><font color="blue">#include  &lt;stdio.h&gt;</font>
<font color="blue">#include  &lt;fcntl.h&gt;</font>
<font color="blue">#include  &lt;stdlib.h&gt;</font>
<font color="blue">#include  &lt;unistd.h&gt;</font>

<font color="blue">#define  MYSIZE      10000</font>

<b>int</b> copy_file(<b>char</b> destination[], <b>char</b> source[])        
{
<font color="green"><i>//  ATTEMPT TO OPEN source FOR READ-ONLY ACCESS</i></font>
    <font color="red"><b>int fd0    = open(source, O_RDONLY)</b></font>;
<font color="green"><i>//  ENSURE THE FILE COULD BE OPENED</i></font>
    <b>if</b>(<font color="red"><b>fd0 == -1</b></font>) {
        <b>return</b> -1;
    }

<font color="green"><i>//  ATTEMPT TO OPEN destination FOR WRITE-ONLY ACCESS</i></font>
    <font color="red"><b>int fd1    = open(destination, O_WRONLY)</b></font>;
<font color="green"><i>//  ENSURE THE FILE COULD BE OPENED</i></font>
    <b>if</b>(<font color="red"><b>fd1 == -1</b></font>) {
        <font color="red"><b>close(fd0)</b></font>;
        <b>return</b> -1;
    }

<font color="green"><i>//  DEFINE A CHARACTER ARRAY TO HOLD THE FILE'S CONTENTS</i></font>
    <b>char</b>   buffer[MYSIZE];
    size_t got;

<font color="green"><i>//  PERFORM MULTIPLE READs OF FILE UNTIL END-OF-FILE REACHED  </i></font>
    <b>while</b>(<font color="red"><b>(got = read(fd0, buffer, sizeof buffer)) &gt; 0</b></font>) {  
        <b>if</b>(<font color="red"><b>write(fd1, buffer, got)) != got</b></font>) {  
            <font color="red"><b>close(fd0)</b></font>; <font color="red"><b>close(fd1)</b></font>;
            <b>return</b> -1;
        }
    }

    <font color="red"><b>close(fd0)</b></font>; <font color="red"><b>close(fd1)</b></font>;
    <b>return</b> 0;
}
</tt></pre>
</td>
</tr></tbody></table>
<p>

	</p><p>
	</p><div style="font-size: 0.7em; color: #888888">
	    CITS2002 Systems Programming, Lecture 8, p2, 16th August 2022.
	</div>
	<hr style="text-align: center; width: 85%;">
	<br>
<h3>Reading and writing <i>text files</i></h3>

We'll next focus on reading and writing from human-readable <i>text files</i>.
C11 provides additional support <i>above</i> the operating systems's
system-calls
to provide more efficient <i>buffering</i> of I/O operations,
and treating text files as a sequence of lines (as strings).
<p></p>

We open a text file using C's <i>fopen()</i> function.
<br>
To this function we pass the name of the file we wish to open
(as a character array),
and describe how we wish to open, and later access, the file.
<p></p>

The returned value is a <i>FILE pointer</i>,
that we use in all subsequent operations with that file.
<p></p>

<table><tbody><tr><td class="code"><pre><tt>
<font color="blue">#include &lt;stdio.h&gt;</font>

<font color="blue">#define DICTIONARY      "/usr/share/dict/words"</font>

....
<font color="green">//  ATTEMPT TO OPEN THE FILE FOR READ-ACCESS</font>
    <font color="red"><b>FILE   *dict = fopen(DICTIONARY, "r")</b></font>;

<font color="green">//  CHECK IF ANYTHING WENT WRONG</font>
    <b>if</b>(<font color="red"><b>dict == NULL</b></font>) {
        printf( "cannot open dictionary '%s'\n", DICTIONARY);
        exit(EXIT_FAILURE);
    }

<font color="green">//  READ AND PROCESS THE CONTENTS OF THE FILE</font>
    ....

<font color="green">//  WHEN WE'RE FINISHED, CLOSE THE FILE</font>
    <font color="red"><b>fclose(dict)</b></font>;
</tt></pre></td></tr></tbody></table>
<p></p>
<p></p>

If <i>fopen()</i> returns the special value <i>NULL</i>,
it indicates that the file may not exist,
or that the operating system is not giving us permission to access it as
requested.
	<p>
	</p><div style="font-size: 0.7em; color: #888888">
	    CITS2002 Systems Programming, Lecture 8, p3, 16th August 2022.
	</div>
	<hr style="text-align: center; width: 85%;">
	<br>
<h3>Declaring how the file will be used</h3>

In different applications,
we may need to open the file in different ways.
<p></p>

We pass different strings as the second parameter to <i>fopen()</i>
to declare how we'll use the file:
<p></p>

<div style="margin-left: 4em;">
<table>
<tbody><tr style="padding: 4px;">
    <td style="padding: 4px; width: 60px">"r"</td>
    <td style="padding: 4px;">open for reading</td>
</tr>

<tr>
    <td style="padding: 4px;">"r+"</td>
    <td style="padding: 4px;">open for reading <i>and</i> writing</td>
</tr>

<tr>
    <td style="padding: 4px;">"w"</td>
    <td style="padding: 4px;">create or truncate file, then open for writing</td>
</tr>

<tr>
    <td style="padding: 4px;">"w+"</td>
    <td style="padding: 4px;">create or truncate file, then open for reading <i>and</i> writing</td>
</tr>

<tr>
    <td style="padding: 4px;">"a"</td>
    <td style="padding: 4px;">create if necessary, then open for appending (at the end of the file)</td>
</tr>

<tr>
    <td style="padding: 4px;">"a+"</td>
    <td style="padding: 4px;">create if necessary, then open for reading <i>and</i> appending</td>
</tr>

</tbody></table>
</div>
<p></p>

All future operations to read and write an open file
are checked against the initial <i>file access mode</i>.
Future operations will <i>fail</i> if they do not match the initial declaration.
<p></p>

<b>NOTE</b> - File access mode flag <i>"b"</i> can optionally be specified
to open a file in <i>binary mode</i> (described later).
This flag has effect only on Windows systems, and is ignored on Linux and macOS.
This flag has no effect when reading and writing text files.
	<p>
	</p><div style="font-size: 0.7em; color: #888888">
	    CITS2002 Systems Programming, Lecture 8, p4, 16th August 2022.
	</div>
	<hr style="text-align: center; width: 85%;">
	<br>
<h3>Reading a text file, one line at a time</h3>

Having opened the file (for read access),
we now wish to read it in -
<i>one line at a time</i>.
<br>
We generally don't need to store each line of text;
we just check or use it as we traverse the file:
<p></p>

The text data in the file is (unsurprisingly) also stored as a sequence
of characters.
We can use C's character arrays to store each line as we read it:
<p></p>

<table><tbody><tr>
<td style="width: 30em; vertical-align: top; padding: 4px;">
<table><tbody><tr><td class="code"><pre><tt>
<font color="blue">#include &lt;stdio.h&gt;</font>

....
    FILE   *dict;
    <b>char</b>   line[BUFSIZ];

    dict = fopen( ..... );
    ....

<font color="green">//  READ EACH LINE FROM THE FILE,</font>
<font color="green">//  CHECKING FOR END-OF-FILE OR AN ERROR</font>
    <b>while</b>( <font color="red">fgets(line, <b>sizeof</b> line, dict) != NULL</font> ) {  
        ....
        ....     <font color="green">// process this line</font>
        ....
    }
<font color="green">//  AT END-OF-FILE (OR AN ERROR), CLOSE THE FILE</font>
    fclose(dict);
</tt></pre></td></tr></tbody></table>
<p></p>
</td>

<td style="vertical-align: top; padding: 4px;">

<b>Of note in this code:</b>
<p></p>

<ul id="bullet">
<li> we pass to <i>fgets()</i> our character array,
	into which each line will be read.
	<p></p>
	</li>

<li> we indicate the maximum size of our array,
	so that <i>fgets()</i> doesn't try to read in too much.
	<p></p>
	</li>

<li>  We use the <b>sizeof</b> operator to indicate the
	maximum size of our character array.
	<br>
	Using <b>sizeof</b> here, rather than just repeating
	the value <i>BUFSIZ</i>,
	means that we can change the size of <i>line</i> at any time,
	by only changing the size at its definition.
	<p></p>
	</li>

<li>  We pass our file pointer, <i>dict</i>,
	to our file-based functions to indicate which file to read or write.
	<br>
	It's possible to have many files open at once.
	<p></p>
	</li>

<li>  The <i>fgets()</i> functions returns the constant <i>NULL</i>
	when it "fails".
	When reading files, this indicates that the end-of-file has
	been reached, or some error detected (e.g. USB key removed!).
	<p></p>
	</li>

<li>  Assuming that we've reached end-of-file,
	and that we only need to read the file once,
	we close the file pointer
	(and just assume that the closing has succeeded).
</li></ul>
</td>
</tr></tbody></table>
	<p>
	</p><div style="font-size: 0.7em; color: #888888">
	    CITS2002 Systems Programming, Lecture 8, p5, 16th August 2022.
	</div>
	<hr style="text-align: center; width: 85%;">
	<br>
<h3>What did we just read from the file?</h3>

Our call to the <i>fgets()</i> function
will have read in <i>all</i> characters on each line of the dictionary but,
if we're interested in processing the characters as simple strings,
we find that we've got "too much".
<p></p>

Each line read will actually have:

<center>
<table style="border: 1px solid gray; font-size: 1.4em;">
<tbody><tr>
<!--
    <td><img src="images/portguy_2.gif"></td>
-->
    <td style="border: 1px solid gray; padding: 8px;">a</td>
    <td style="border: 1px solid gray; padding: 8px;">a</td>
    <td style="border: 1px solid gray; padding: 8px;">r</td>
    <td style="border: 1px solid gray; padding: 8px;">d</td>
    <td style="border: 1px solid gray; padding: 8px;">v</td>
    <td style="border: 1px solid gray; padding: 8px;">a</td>
    <td style="border: 1px solid gray; padding: 8px;">r</td>
    <td style="border: 1px solid gray; padding: 8px;">k</td>
    <td style="border: 1px solid gray; padding: 8px; background-color: lightgreen;">\n</td>
    <td style="border: 1px solid gray; padding: 8px;">\0</td>
</tr>
</tbody></table>
</center>
<p></p>

The character '\n',
the familiar <i>newline</i> character often used in <i>print()</i>,
is silently added to text lines by our text editors.
<p></p>

In fact on Windows' machines,
text files <i>also</i> include a <i>carriage-return</i> character before
the newline character.
<p></p>

<center>
<table style="border: 1px solid gray; font-size: 1.4em;">
<tbody><tr>
    <td style="border: 1px solid gray; padding: 8px;">W</td>
    <td style="border: 1px solid gray; padding: 8px;">i</td>
    <td style="border: 1px solid gray; padding: 8px;">n</td>
    <td style="border: 1px solid gray; padding: 8px;">d</td>
    <td style="border: 1px solid gray; padding: 8px;">o</td>
    <td style="border: 1px solid gray; padding: 8px;">w</td>
    <td style="border: 1px solid gray; padding: 8px;">s</td>
    <td style="border: 1px solid gray; padding: 8px; background-color: lightgreen;">\r</td>
    <td style="border: 1px solid gray; padding: 8px; background-color: lightgreen;">\n</td>
    <td style="border: 1px solid gray; padding: 8px;">\0</td>
</tr>
</tbody></table>
</center>
<p></p>

As we know,
we can simply turn this into a more manageable string
by replacing the newline or carriage-return character by the
<i>null-byte</i>.
	<p>
	</p><div style="font-size: 0.7em; color: #888888">
	    CITS2002 Systems Programming, Lecture 8, p6, 16th August 2022.
	</div>
	<hr style="text-align: center; width: 85%;">
	<br>
<h3>Trimming end-of-line characters from a line</h3>

To make future examples easy to read,
we'll write a function, named <i>trim_line()</i>,
that receives a line (a character array) as a parameter,
and "removes" the first carriage-return or newline character that it finds.
<p></p>

It's very similar to functions like <i>my_strlen()</i>
that we've written in laboratory work:
<p></p>

<table><tbody><tr><td class="code"><pre><tt>
<font color="green">//  REMOVE ANY TRAILING end-of-line CHARACTERS FROM THE LINE</font>
<b>void</b> trim_line(<b>char</b> line[])
{
    <b>int</b> i = 0;

<font color="green">//  LOOP UNTIL WE REACH THE END OF line</font>
    <b>while</b>(line[i] != '\0') {

<font color="green">//  CHECK FOR CARRIAGE-RETURN OR NEWLINE</font>
        <b>if</b>( <font color="red"><b>line[i] == '\r' || line[i] == '\n'</b></font> ) {
            line[i] = '\0'; <font color="green">// overwrite with null-byte</font>
            <b>break</b>;          <font color="green">// leave the loop early</font>
        }
        i = i+1;            <font color="green">// iterate through character array</font>
    }
}
</tt></pre></td></tr></tbody></table>
<p></p>
<p></p>

We note:
<p></p>

<ul id="bullet">
<li> we simply overwrite the unwanted character with the <i>null-byte</i>.

</li><li> the function will actually modify the <i>caller's</i> copy of the variable.

</li><li> we do not return any value.
</li></ul>

	<p>
	</p><div style="font-size: 0.7em; color: #888888">
	    CITS2002 Systems Programming, Lecture 8, p7, 16th August 2022.
	</div>
	<hr style="text-align: center; width: 85%;">
	<br>
<h3>Writing text output to a file</h3>

We've used <i>fgets()</i> to 'get' a line of text (a string) from a file;
<br>
we similarly use <i>fputs()</i> to 'put' (write) a line of text.
<p></p>

The file pointer passed to <i>fputs()</i> must previously have been opened for
<i>writing</i> or appending.
<p></p>

<h3>Copying a text file using file pointers</h3>

We now have all the functions necessary to copy one text file to another,
one line line at a time:
<p></p>

<table><tbody><tr><td class="code"><pre><tt>
<font color="blue">#include &lt;stdio.h&gt;</font>
<font color="blue">#include &lt;stdlib.h&gt;</font>

<b>void</b> copy_text_file(<b>char</b> destination[], <b>char</b> source[])
{
    FILE        *fp_in   = fopen(source, "r");
    FILE        *fp_out  = fopen(destination,  "w");

<font color="green">//  ENSURE THAT OPENING BOTH FILES HAS BEEN SUCCESSFUL</font>
    <b>if</b>(fp_in != NULL &amp;&amp; fp_out != NULL) {
        <b>char</b>    line[BUFSIZ];

        <b>while</b>( <font color="red"><b>fgets(line, <b>sizeof</b> line, fp_in) != NULL</b></font>) {  
            <b>if</b>(<font color="red"><b>fputs(line, fp_out) == EOF</b></font>) {
                printf("error copying file\n");
                exit(EXIT_FAILURE);
            }
        }
    }
<font color="green">//  ENSURE THAT WE ONLY CLOSE FILES THAT ARE OPEN</font>
    <b>if</b>(fp_in != NULL) {
        fclose(fp_in);
    }
    <b>if</b>(fp_out != NULL) {
        fclose(fp_out);
    }
}
</tt></pre></td></tr></tbody></table>
<p></p>
<p></p>
	<p>
	</p><div style="font-size: 0.7em; color: #888888">
	    CITS2002 Systems Programming, Lecture 8, p8, 16th August 2022.
	</div>
	<hr style="text-align: center; width: 85%;">
	<br>
<h3>More text file reading - the game of Scrabble</h3>

Let's quickly consider another example employing reading a text file.
<p></p>

<table><tbody><tr>
<td style="vertical-align: top; padding: 4px;">
<img src="CITS2002%20Lecture%20-%20File%20acess_files/scrabble.png" alt="scrabble" width="250">
</td>

<td style="vertical-align: top; padding: 4px;">
In the game of Scrabble, each letter tile has a certain value -
the rarer a letter is in the English language,
the higher the value of that letter
('E' is common and has the value 1,
'Q' is rare and has the value 10).
<p></p>

Can we write C functions to determine:
<p></p>

<ul id="bullet">
    <li> the value of a word in Scrabble?
    </li><li> the word in a dictionary with the highest value?
    </li><li> the best word to choose from a set of tiles?
</li></ul>
</td>
</tr>

<tr>
<td style="vertical-align: top; padding: 4px;">
In writing these functions we won't consider all of the rules of Scrabble.
<p></p>

Another consideration (which we'll ignore)
is that there are fixed tile frequencies -
for example,
there are 12 'E's but only 1 'Q'.
<p></p>

Refer to <a href="https://en.wikipedia.org/wiki/Scrabble_letter_distributions">Wikipedia</a> for the actual distributions.
</td>

<td style="vertical-align: top; padding: 4px;">
    <img src="CITS2002%20Lecture%20-%20File%20acess_files/chickenscrabble.jpg" alt="scrabble" width="250">
</td>
</tr></tbody></table>
	<p>
	</p><div style="font-size: 0.7em; color: #888888">
	    CITS2002 Systems Programming, Lecture 8, p9, 16th August 2022.
	</div>
	<hr style="text-align: center; width: 85%;">
	<br>
<h3>The value of a word in Scrabble</h3>

To answer our Scrabble questions,
we'll develop two simple helper functions:

<table><tbody><tr>
<td style="vertical-align: top; padding: 8px;">
<table><tbody><tr><td class="code"><pre><tt>
<font color="blue">#include &lt;stdbool.h&gt;</font>
<font color="blue">#include &lt;string.h&gt;</font>
<font color="blue">#include &lt;ctype.h&gt;</font>

<font color="green">//  ENSURE THAT A WORD CONTAINS ONLY LOWERCASE CHARACTERS</font>
<b>bool</b> valid_word(<b>char</b> word[])
{
    <b>int</b> i = 0;

<font color="green">//  IF NOT A LOWERCASE CHARACTER, THE FUNCTION RETURNS false</font>
    <b>while</b>(word[i] != '\0') {
	<b>if</b>( <font color="red"><b>! islower( word[i] )</b></font>) {   <font color="green">//  if not islower ...</font>
            <b>return</b> false;
        }
        i = i+1;
    }
<font color="green">//  WE'VE REACHED THE END OF THE WORD - IT'S ALL LOWERCASE</font>
    <b>return</b> true;
}

<font color="green">//  CALCULATE THE SCRABBLE VALUE OF ANY WORD</font>
<b>int</b> calc_value(<b>char</b> word[])
{
<font color="green">//  AN ARRAY TO PROVIDE THE VALUE OF EACH LETTER, FROM 'a' TO 'z'</font>  
    <b>int</b> values[] = {  1, 3, 3, 2, 1, 4, 2, 4, 1, 8, 5, 1, 3, 1,  
                      1, 3, 10, 1, 1, 1, 1, 4, 4, 8, 4, 10 };
    <b>int</b> total    = 0;
    <b>int</b> i        = 0;

<font color="green">//  TRAVERSE THE WORD DETERMINING THE VALUE OF EACH LETTER</font>
    <b>while</b>(word[i] != '\0') {
        total   = total + values[ <font color="red"><b>word[i] - 'a'</b></font> ];
        i = i+1;
    }
    <b>return</b> total;
}
</tt></pre></td></tr></tbody></table>
<p></p>
</td>

<td style="vertical-align: top; padding: 8px;">
<table width="10%" cellspacing="0" cellpadding="2" border="1" bgcolor="#dddddd" align="right">
<tbody><tr>
	<td style="border: 1px solid gray; padding: 8px; background-color: #ddd;"><b>Letter</b></td>
	<td style="border: 1px solid gray; padding: 8px; background-color: #ddd;"><b>Value</b></td>
</tr>
<tr>
	<td style="border: 1px solid gray; padding: 2px; text-align: center;">A</td>
	<td style="border: 1px solid gray; padding: 2px; text-align: center;">1</td>
</tr>
<tr>
	<td style="border: 1px solid gray; padding: 2px; text-align: center;">B</td>
	<td style="border: 1px solid gray; padding: 2px; text-align: center;">3</td>
</tr>
<tr>
	<td style="border: 1px solid gray; padding: 2px; text-align: center;">C</td>
	<td style="border: 1px solid gray; padding: 2px; text-align: center;">3</td>
</tr>
<tr>
	<td style="border: 1px solid gray; padding: 2px; text-align: center;">D</td>
	<td style="border: 1px solid gray; padding: 2px; text-align: center;">2</td>
</tr>
<tr>
	<td style="border: 1px solid gray; padding: 2px; text-align: center;">E</td>
	<td style="border: 1px solid gray; padding: 2px; text-align: center;">1</td>
</tr>
<tr>
	<td style="border: 1px solid gray; padding: 2px; text-align: center;">F</td>
	<td style="border: 1px solid gray; padding: 2px; text-align: center;">4</td>
</tr>
<tr>
	<td style="border: 1px solid gray; padding: 2px; text-align: center;">G</td>
	<td style="border: 1px solid gray; padding: 2px; text-align: center;">2</td>
</tr>
<tr>
	<td style="border: 1px solid gray; padding: 2px; text-align: center;">H</td>
	<td style="border: 1px solid gray; padding: 2px; text-align: center;">4</td>
</tr>
<tr>
	<td style="border: 1px solid gray; padding: 2px; text-align: center;">I</td>
	<td style="border: 1px solid gray; padding: 2px; text-align: center;">1</td>
</tr>
<tr>
	<td style="border: 1px solid gray; padding: 2px; text-align: center;">J</td>
	<td style="border: 1px solid gray; padding: 2px; text-align: center;">8</td>
</tr>
<tr>
	<td style="border: 1px solid gray; padding: 2px; text-align: center;">K</td>
	<td style="border: 1px solid gray; padding: 2px; text-align: center;">5</td>
</tr>
<tr>
	<td style="border: 1px solid gray; padding: 2px; text-align: center;">L</td>
	<td style="border: 1px solid gray; padding: 2px; text-align: center;">1</td>
</tr>
<tr>
	<td style="border: 1px solid gray; padding: 2px; text-align: center;">M</td>
	<td style="border: 1px solid gray; padding: 2px; text-align: center;">3</td>
</tr>
<tr>
	<td style="border: 1px solid gray; padding: 2px; text-align: center;">N</td>
	<td style="border: 1px solid gray; padding: 2px; text-align: center;">1</td>
</tr>
<tr>
	<td style="border: 1px solid gray; padding: 2px; text-align: center;">O</td>
	<td style="border: 1px solid gray; padding: 2px; text-align: center;">1</td>
</tr>
<tr>
	<td style="border: 1px solid gray; padding: 2px; text-align: center;">P</td>
	<td style="border: 1px solid gray; padding: 2px; text-align: center;">3</td>
</tr>
<tr>
	<td style="border: 1px solid gray; padding: 2px; text-align: center;">Q</td>
	<td style="border: 1px solid gray; padding: 2px; text-align: center;">10</td>
</tr>
<tr>
	<td style="border: 1px solid gray; padding: 2px; text-align: center;">R</td>
	<td style="border: 1px solid gray; padding: 2px; text-align: center;">1</td>
</tr>
<tr>
	<td style="border: 1px solid gray; padding: 2px; text-align: center;">S</td>
	<td style="border: 1px solid gray; padding: 2px; text-align: center;">1</td>
</tr>
<tr>
	<td style="border: 1px solid gray; padding: 2px; text-align: center;">T</td>
	<td style="border: 1px solid gray; padding: 2px; text-align: center;">1</td>
</tr>
<tr>
	<td style="border: 1px solid gray; padding: 2px; text-align: center;">U</td>
	<td style="border: 1px solid gray; padding: 2px; text-align: center;">1</td>
</tr>
<tr>
	<td style="border: 1px solid gray; padding: 2px; text-align: center;">V</td>
	<td style="border: 1px solid gray; padding: 2px; text-align: center;">4</td>
</tr>
<tr>
	<td style="border: 1px solid gray; padding: 2px; text-align: center;">W</td>
	<td style="border: 1px solid gray; padding: 2px; text-align: center;">4</td>
</tr>
<tr>
	<td style="border: 1px solid gray; padding: 2px; text-align: center;">X</td>
	<td style="border: 1px solid gray; padding: 2px; text-align: center;">8</td>
</tr>
<tr>
	<td style="border: 1px solid gray; padding: 2px; text-align: center;">Y</td>
	<td style="border: 1px solid gray; padding: 2px; text-align: center;">4</td>
</tr>
<tr>
	<td style="border: 1px solid gray; padding: 2px; text-align: center;">Z</td>
	<td style="border: 1px solid gray; padding: 2px; text-align: center;">10</td>
</tr>
</tbody></table>
</td>

</tr></tbody></table>
	<p>
	</p><div style="font-size: 0.7em; color: #888888">
	    CITS2002 Systems Programming, Lecture 8, p10, 16th August 2022.
	</div>
	<hr style="text-align: center; width: 85%;">
	<br>
<h3>The word with the highest value</h3>

Can we find which <i>valid</i> word from a dictionary has the highest
value?
<p></p>

<table><tbody><tr><td class="code"><pre><tt>
<font color="blue">#include &lt;stdio.h&gt;</font>
<font color="blue">#include &lt;stdbool.h&gt;</font>
<font color="blue">#include &lt;string.h&gt;</font>
<font color="blue">#include &lt;ctype.h&gt;</font>

<font color="blue">#define DICTIONARY      "/usr/share/dict/words"</font>
<font color="blue">#define LONGEST_WORD    100</font>

<font color="green">//  FIND THE WORD WITH THE BEST VALUE</font>
<b>void</b> findbest( <b>char</b> filename[] )
{
    FILE        *fp  = fopen(filename, "r");

<font color="green">//  ENSURE THAT WE CAN OPEN (WITH READ-ACCESS) THE FILE</font>
    <b>if</b>(fp != NULL) {
        <b>char</b>    bestword[LONGEST_WORD];
        <b>int</b>     bestvalue       = 0;
        <b>char</b>    thisword[LONGEST_WORD];
        <b>int</b>     thisvalue       = 0;

<font color="green">//  READ EACH LINE OF THE FILE</font>
        <b>while</b>( fgets(thisword, <b>sizeof</b> thisword, fp) != NULL ) {
<font color="green">//  REPLACE THE NEWLINE CHARACTER WITH A NULL-BYTE</font>
            <font color="red"><b>trim_line( thisword )</b></font>;

<font color="green">//  ENSURE THAT THIS WORD IS VALID (previously defined)</font>
            <b>if</b>( <font color="red"><b>valid_word(thisword)</b></font> ) {
                thisvalue = <font color="red"><b>calc_value( thisword )</b></font>;

<font color="green">//  IS THIS WORD BETTER THAN THE PREVIOUSLY BEST?</font>
                <b>if</b>(bestvalue &lt; thisvalue) {
                    bestvalue   = thisvalue;    <font color="green">// save current details</font>
                    strcpy(bestword, thisword);
                }
            }
        }
        fclose(fp);
        printf("best word is %s = %i\n", bestword, bestvalue);
    }
}

<b>int</b> main(<b>int</b> argc, <b>char</b> *argv[])
{
    findbest( DICTIONARY );
    <b>return</b> 0;
}
</tt></pre></td></tr></tbody></table>
<p></p>

<br>
<a href="https://teaching.csse.uwa.edu.au/units/CITS2002/lectures/lecture08/src/bestword.c">Full solution here</a>.
	<p>
	</p><div style="font-size: 0.7em; color: #888888">
	    CITS2002 Systems Programming, Lecture 8, p11, 16th August 2022.
	</div>
	<hr style="text-align: center; width: 85%;">
	<br>
<h3>Reading and writing files of <i>binary data</i></h3>

To date,
our use of files has dealt exclusively with lines of text,
using <i>fgets()</i> and <i>fputs()</i> to perform our I/O.
<p></p>

This has provided a good introduction to file input/output (I/O)
as textual data is easy to "see",
and printing it to the screen helps us to verify our functions:
<p></p>

<ul id="bullet">
<li> the standard <i>fgets</i> function manages the differing lengths of
    input lines by reading until the '\n' or '\r' character is found,
    <p></p>
    </li>

<li> <i>fgets</i> terminates input lines by appending a <i>null-byte</i> to
    them, 'turning' them into C strings, and
    <p></p>
    </li>

<li> the <i>null-byte</i> is significant when later
    managing (copying, printing, ...) strings.
    </li>
</ul>
<p></p>
	<p>
	</p><div style="font-size: 0.7em; color: #888888">
	    CITS2002 Systems Programming, Lecture 8, p12, 16th August 2022.
	</div>
	<hr style="text-align: center; width: 85%;">
	<br>
<h3>Reading and writing files of binary data, <i>continued</i></h3>

However, when managing files of arbitrary data,
possibly including <i>null-bytes</i> as well,
we must use different functions to handle binary data:
<p></p>

<table><tbody><tr><td class="code"><pre><tt>
<font color="blue">#include &lt;stdio.h&gt;</font>
<font color="blue">#include &lt;stdlib.h&gt;</font>

<b>void</b> copyfile(<b>char</b> destination[], <b>char</b> source[])
{
    FILE        *fp_in   = fopen(source, "rb");
    FILE        *fp_out  = fopen(destination,  "wb");

<font color="green">//  ENSURE THAT OPENING BOTH FILES HAS BEEN SUCCESSFUL</font>
    <b>if</b>(fp_in != NULL &amp;&amp; fp_out != NULL) {

        <b>char</b>    buffer[BUFSIZ];
        size_t  got, wrote;

        <b>while</b>( (got = <font color="red"><b>fread(buffer, 1, sizeof buffer, fp_in)</b></font>) &gt; 0) {  
            wrote = <font color="red"><b>fwrite(buffer, 1, got, fp_out)</b></font>;
            <b>if</b>(wrote != got) {
                printf("error copying files\n");
                exit(EXIT_FAILURE);
            }
        }

    }

<font color="green">//  ENSURE THAT WE ONLY CLOSE FILES THAT ARE OPEN</font>
    <b>if</b>(fp_in != NULL) {
        fclose(fp_in);
    }
    <b>if</b>(fp_out != NULL) {
        fclose(fp_out);
    }
}
</tt></pre></td></tr></tbody></table>
<p></p>
<p></p>

<b>NOTE</b> - The access mode flag <i>"b"</i> has been used in both calls to
<i>fopen()</i> as we're anticipating opening <i>binary</i> files.
This flag has effect only on Windows systems, and is ignored on Linux and macOS.
This flag has no effect when reading and writing text files.
<p></p>

While we might <i>request</i> that <i>fread()</i> fetches a known number of
bytes, <i>fread()</i> might not provide them all!
<p></p>

<ul id="bullet">
    <li> we might be reading the last "part" of a file, or
    </li><li> the data may be arriving (slowly) over a network connection, or
    </li><li> the operating system may be too busy to provide them all right now.
</li></ul>
	<p>
	</p><div style="font-size: 0.7em; color: #888888">
	    CITS2002 Systems Programming, Lecture 8, p13, 16th August 2022.
	</div>
	<hr style="text-align: center; width: 85%;">
	<br>
<h3>Reading and writing <i>binary data structures</i></h3>

The <i>fread()</i> function reads an indicated number of elements,
each of which is the same size:
<p></p>

<pre>    size_t  fread(void *ptr, size_t eachsize, size_t nelem, FILE *stream);
</pre>
<p></p>

This mechanism enables our programs to read arbitrary sized data,
by setting <i>eachsize</i> to one (a single byte),
or to read a known number of data items each of the same size:
<p></p>

<table><tbody><tr><td class="code"><pre><tt>
<font color="blue">#include &lt;stdio.h&gt;</font>

<b>int</b>   intarray[ N_ELEMENTS ];
<b>int</b>   got, wrote;

<font color="green">//  OPEN THE BINARY FILE FOR READING AND WRITING</font>
    FILE  *fp = fopen(filename, <font color="red"><b>"rb+"</b></font>);
    ....

    got = <font color="red"><b>fread</b></font>( intarray, <b>sizeof int</b>, N_ELEMENTS, fp);  
    printf("just read in %i ints\n", got);

<font color="green">//  MODIFY THE BINARY DATA IN THE ARRAY</font>
    ....

<font color="green">//  REWIND THE FILE TO ITS BEGINNING</font>
    <font color="red"><b>rewind(fp)</b></font>;

<font color="green">//  AND NOW OVER-WRITE THE BEGINNING DATA</font>
    wrote = <font color="red"><b>fwrite</b></font>( intarray, <b>sizeof int</b>, N_ELEMENTS, fp);  
    ....

    fclose(fp);
</tt></pre></td></tr></tbody></table>
<p></p>
<p></p>

	<p>
	</p><div style="font-size: 0.7em; color: #888888">
	    CITS2002 Systems Programming, Lecture 8, p14, 16th August 2022.
	</div>
	<hr style="text-align: center; width: 85%;">
	<br>
<h3>Reading and writing binary data structures, <i>continued</i></h3>

When reading and writing arbitrary binary data,
there is an important consideration -
different hardware architectures (the computer's CPU and data
circuitry) store and manipulate their data in different formats.
<p></p>

The result is that when binary data <i>written</i> via one
architecture (such as an Intel Pentium)
is <i>read</i> back on a different architecture (such as an IBM PowerPC),
the "result" will be different!
<p></p>

<table><tbody><tr>
<td style="vertical-align: top;">
Writing on a 32-bit Intel Pentium:
<p></p>

<table><tbody><tr><td class="code"><pre><tt>
<font color="blue">#include &lt;stdio.h&gt;</font>

<font color="blue">#define N     10</font>

  <b>int</b> array[N];

  <b>for</b>(<b>int</b> n=0 ; n &lt; N ; ++n) {
      array[n]  =  n;
  }

  fwrite(array, N, <b>sizeof int</b>, fp_out);

</tt></pre></td></tr></tbody></table>
<p></p>
</td>

<td style="vertical-align: top;">
Reading on a 32-bit PowerPC:
<p></p>

<table><tbody><tr><td class="code"><pre><tt>
<font color="blue">#include &lt;stdio.h&gt;</font>

<font color="blue">#define N     10</font>

  <b>int</b> array[N];

  fread(array, N, <b>sizeof int</b>, fp_in);  

  <b>for</b>(<b>int</b> n=0 ; n &lt; N ; ++n) {
      printf("%i ", array[n]);
  }
  printf("\n");
</tt></pre></td></tr></tbody></table>
<p></p>

</td></tr></tbody></table>

Prints the output:

<pre>0 16777216 33554432 50331648 67108864 83886080 100663296 117440512 134217728 150994944
</pre>
<p></p>

The problems of reading and writing of binary data,
to and from different architectures and across networks,
are discussed and solved in later units, such as
<a href="https://teaching.csse.uwa.edu.au/units/CITS3002/"><i>CITS3002 Computer Networks</i></a>.
<p></p>


<p>&nbsp;</p>
<font size="-2">
<i>Jonathan Swift's
<a href="https://en.wikipedia.org/wiki/Gulliver's_Travels"><i>Gulliver's Travels</i></a>, published in 1726,
provided the earliest literary reference to computers,
in which a machine would write books.
This early attempt at artificial intelligence was characteristically
marked by its inventor's call for public funding and the employment of
student operators.
Gulliver's diagram of the machine actually contained errors,
these being either an attempt to protect his invention or the first
computer hardware glitch.
<p></p>

</i></font><p><font size="-2"><i>
The term <i>endian</i>
is used because of an analogy with the story Gulliver's
Travels, in which Swift imagined a never-ending fight between
the kingdoms of the Big-Endians and the Little-Endians
(whether you were Lilliputian or Brobdignagian),
whose only difference is in where they crack open a hard-boiled egg.</i>
</font>
	</p><p>
	</p><div style="font-size: 0.7em; color: #888888">
	    CITS2002 Systems Programming, Lecture 8, p15, 16th August 2022.
	</div>
	<hr style="text-align: center; width: 85%;">
	<br>

    </td></tr></tbody></table>


<div id="forest-ext-shadow-host"></div></body></html>